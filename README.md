# M2AP-zvanzura-jcdiorio
Testing Randomness Process:
We both agreed that the best way to test the randomness of our methods was to run our random methods a bunch of times (100,000+) and count how many times a value remains at its start index. In theory, the frequency that this should happen is equal to the expected frequency of the value occurring at any other index. 
Obviously if you have a deck of cards that is shuffled where the start and end location of each card is different from the original but the ordering of the cards is still the same, that isn't a very good shuffle. So we had to implement a similar method to make sure that both the indexes and the ordering of the shuffled vector were different from the original.

This means that if there are 10 entries in a data set, it is reasonable to expect the value to remain at its index 1/10th of the time. If we run the random methods 1,000,000 times, we would expect a dataset of 10 entries to have "unswapped" frequencies of around 100,000.
Unswapped is put in quotes because the swap actually happens, it is just that the start and destination indexes are the same. The frequency of rotated vector occurrences should be around 0

### Results
Jack's randomness method when run through the test function using a vector size of 10 and 1,000,000 iterations returns repeat counts similar to [ 112_529, 52_179, 440_727, 52179, 323_886, 159_912, 112_529, 112_529, 52_179, 52_179 ] every time. This shows that while some values are barely ever in their same index (52179), other values are disproportionately always at some index, as shown by the values 440727 and 323886. The ideal values here would be 100,000 across the board, showing that each value has an equal chance to appear in any other index. So although the randomness is not perfect, it does include the acceptable range, and with some variation does somewhat randomly shuffle the vector of 10 items.
Zach's randomness method when run with the same vector of 10 and run through 1,000,000 iterations of the method returns a repeat counts similar to [ 131_628, 78_248, 97_882, 86_410, 84_031, 142_391, 131_285, 118_506, 99_138, 90_463]. Zach's return values demonstrate a very good distribution of randomness with a range of (78_248 - 142_391) which is relatively close enough to the ideal values of 100_000 repeats for every index. Despite some variation, it is reasonable to say that Zach's random method produces a satisfiable randomized vector.
Furthermore, both Zach and Jack's methods return rotate counts of 0. It is completely possible that this is due to a logic error within the logic of testing for a rotation. However, that logic is relatively simple, and it is more likely that the logic of both random methods makes it incredibly unlikely that a randomized vector will be in the same relative ordering as the original vector.
Admittedly, the logic in the method to test for a shuffle only accounts for if the entire randomized vector is in the same relative ordering. It is entirely possible to have an iteration that is nearly in the same relative ordering with only one index swapped with another (ex: [1, 2,3, 4, 5, 6, 7, 9, 8, 10]). Given more time and a more intentional implementation of the random methods, it would be smart to test for a certain level of relative sameness.

Random number source for Zach's code: https://medium.com/@sourav39.csesust/random-number-generation-in-c-c-without-library-function-d031ccab201d this was not used as both random methods use the built-in rand function.