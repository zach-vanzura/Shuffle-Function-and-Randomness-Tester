# Pseudo Random Shuffle Methods and Quality Testing Function
#### By: Zach Vanzura and Jack Diorio
### Summary ##
This project was a collaborative effort between myself, Zach Vanzura, and my classmate, Jack Diorio. The purpose of this project was first: To Implement our own methods for shuffling a dataset. Then: Implement a method to test the quality of our shuffle methods.    

### My Randomness Method: 
The logic behind my shuffle method was inspired by the shuffling a deck of cards. However, I didn't want to only split the vector in half and then reinsert the values by alternating vectors. The method first splits the vector in half and then gets three random numbers: the first two are for random indices in each half and the third for the number of times the method repeats itself. Then, the method iterates through both halves and performs a three line swap to move each index to another random index. Finally, the method reinserts the values by alternating between the two halves similar to a tradition card shuffle.  
Essentially, my method works by splitting a dataset in half, then randomizing all the values in each half and shuffling the halves back into one whole and then doing that process a random number of times.

### Testing Randomness Process:
Jack and I both agreed that the best way to test the randomness of our methods was to run them numerous times (around 1,000,000) and count how many times a value remains at its start index. In theory, the frequency that this should happen is equal to the expected frequency of the value occurring at any index.   

Another factor in testing the quality of our randomness was to test the relative ordering of our datasets after being shuffled. Obviously, if you have a deck of cards that is shuffled where the start and end location of each card is different from the original but the ordering of the cards is still the same, that isn't a very good shuffle. So we implemented a similar method to make sure that both the indices and the ordering of the shuffled vector were different from the original. We did this by utilizing the rotate method within the vector library and comparing the shuffled vector to a rotated version of the original vector, ensuring to test for rotations by 1 index all the way up to n - 1 indices where n is the size of the dataset (a rotation of n indices is equal to no rotation at all).

This means that if there are 10 entries in a data set, it is reasonable to expect the value to remain at its index 1/10th of the time. If we run the random methods 1,000,000 times, we would expect a dataset of 10 entries to be "unswapped"  around 100,000 times.
Unswapped is put in quotes because the swap actually happens, the start and end destination indexes are just the same. The frequency the vector is rotated should be around 0.  

### Results:
Jack's randomness method when run through the test function using a vector size of 10 and 1,000,000 iterations returns repeat counts in the range of [112,529, 52,179, 440,727, 52,179, 323,886, 159,912, 112,529, 112,529, 52,179, 52,179] every time. This shows that while some values are barely ever in their same index (52,179), other values are disproportionately always at some index, as shown by the values 440,727 and 323,886. The ideal values here would be 100,000 across the board, showing that each value has an equal chance to appear in any other index. So although the randomness is not perfect, it does include the acceptable range, and with some variation does somewhat randomly shuffle the vector of 10 items.
My randomness method when run with the same vector of 10 and run through 1,000,000 iterations of the method returns a repeat counts in the range of [ 131,628, 78,248, 97,882, 86,410, 84,031, 142,391, 131,285, 118,506, 99138, 90,463]. My return values demonstrate a very good distribution of randomness with a range of (78,248 - 142,391) which is relatively close to the ideal values of 100,000 repeats for every index. Despite some variation, it is reasonable to say that it produces a satisfiable randomized vector.  

Furthermore, both mine and Jack's methods return rotate counts of 0. While it is completely possible that this is due to a logic error within the logic of testing for a rotation, that logic is relatively simple and, it is more likely that the logic of both random methods makes it incredibly unlikely that a randomized vector will be in the same relative ordering as the original vector.
Admittedly, the logic in the method to test for a shuffle only accounts for if the entire randomized vector is in the same relative ordering. It is entirely possible to have an iteration that is nearly in the same relative ordering with only one index swapped with another (ex: [1, 2, 3, 4, 5, 6, 7, 9, 8, 10]). 

### Changes for the future:
With further and a more intentional implementation of the random methods, it would be smart to test for a certain level of relative sameness. Like I mentioned above, the test method only tests for a true rotation which isn't a particularly accurate representation of the quality of a shuffle. Additionally, this project uses the C++ rand library which we wanted to avoid because of its pseudo-randomness. We considered getting random numbers from sources like [lava rand](https://www.lavarand.org/) or the number of lightning strikes on the planet at a given time but due to the timeline of the project, we settled on using the rand library which is certainly another limitation to the quality of a shuffle that we can produce.  
Additionally, due to the way my shuffle function works, it won't do a very good job of shuffling datasets of sizes less than four as there aren't enough values to shuffle in at least one of the two halves. Given a more intentional implementation of this project, it would be necessary to add additional logic to produce a high quality shuffle on smaller datasets(although there are only 6 ways to shuffle 3 objects).  

### Sources:

All code in this project was written completely by either myself or by Jack Diorio. Along with Jack's shuffle method, Jack wrote the majority of the utility methods within the DataList.h template class and the testing function that corresponds to them in the main file. I wrote the getRandomNumber helper function(used only in my own shuffle method), my own shuffle method, as well as all the logic to test both of our shuffle methods in main.